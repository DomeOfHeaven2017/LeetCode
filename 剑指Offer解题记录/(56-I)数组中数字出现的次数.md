#### (56-I)数组中数字出现的次数

##### 问题描述

```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

示例 1：
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

示例 2：
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
 
限制：
2 <= nums <= 10000
```

##### 解题思路

>三种解法：
>
>1. 排序法：先排序，则相等的两个会被排在一起，然后分别从前后遍历找到不等的两个数
>
>2. HashMap:使用Hash表来判断是否有相同的值
>
>   前两种方法虽然能解决问题，但都无法满足时间复杂度 $O(n)$ 和空间复杂度 $O(1)$的要求
>
>3. 异或法：
>
>   - 根据相同的数进行异或后抵消的特点可以遍历数组，得到两个单次出现数的异或
>
>   - 然后使用$lowbit$函数取得数第一个1出现的位置
>
>     $lowbit(x) = 2^k$ 第k位即x中第一个1出现的位置
>
>   - 因为两个数不相等，所以通过将这个数分别和数组中的数进行与运算时，会将数组中的数分成两个组（与运算为0的为一组，不为0的为一组），两个不同的数分在两个组中
>
>   - 然后将筛选出来的数再进行异或，抵消掉组中相同的数，剩下的即为结果中的一个数

##### 代码

```java
/**
     * 面试题56-I
     * 数组中数字出现的次数
     * @param nums 所给数组
     * @return 单次次数出现的数字集合
     */
public static int[] singleNumbers(int[] nums) {
    if (nums == null || nums.length <= 2 || nums.length >= 10000) {
        return nums;
    }
    //抵消掉相同的数，计算出两个单次数字的异或
    int xor = 0;
    for (int i : nums) {
        xor ^= i;
    }
    //lowbit函数计算从低到高第一个1出现的位置
    int index = xor & (-xor);
    int x = 0;
    for (int i : nums) {
        //将数据分成两组
        if ((index & i) != 0) {
            //再次将相同的数抵消
            x ^= i;
        }
    }
    return new int[]{x, x ^ xor};
}
```